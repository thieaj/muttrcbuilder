let _ = require("underscore");
let $ = require("jquery");
let Backbone = require("backbone");
let FileSaver = require("file-saver");
Backbone.$ = $;

import ScreenSections from "./ScreenSections";

class ChooseFormatView extends Backbone.View.extend({
    template: _.template(`
<form>
  <p>How would you like your <tt>muttrc</tt> formatted?</p>
  <p>
    <label>
      <input type="radio" name="format" value="minimal" />
      Only print out the values that are different from the default.
    </label>
    <br />
    <label>
      <input type="radio" name="format" value="all" checked="checked" />
      Print out all values, with values that are their default
      commented out.
    </label>
    <br />
    <label>
      <input type="radio" name="format" value="categories" />
      As above, but organised by category.
    </label>
    <br />
    <label>
      <input type="radio" name="format" value="full" />
      Print out the variable reference section of the mutt manual, with
      the variables filled in.
    </label>
  </p>
  <p>
    <button type="button" id="chooseFormat">Build my muttrc</button>
  </p>
</form>
        `),

    events: {
        "click #chooseFormat": "formatSelected"
    }
}) {
    render() {
        this.$el.html(this.template({versions: this.model}));
        return this.$el;
    }

    formatSelected() {
        let handler = {
            all: () => this.saveFullFormat(),
            categories: () => this.saveCategoryFormat(),
            full: () => this.saveManualFormat(),
            minimal: () => this.saveBasicFormat()
        }[$("input[name='format']:checked").val()];
        handler();
    }

    close() {
        this.remove();
        this.unbind();
    }

    getFileHeader() {
        return [
            "# Generated by the muttrc builder\n",
            "# for mutt-" + this.model.get("id") + "\n",
            "\n"
        ];
    }

    saveBasicFormat() {
        let lines = this.getFileHeader();
        for (let attr of this.model.get("attrs").models) {
            let line = this.writeAttr(attr, false);
            if (line) {
                lines.push(line);
            }
        }
        lines = lines.concat(this.writeColours());
        this.writeFile(lines);
    }

    saveFullFormat() {
        let lines = this.getFileHeader();
        for (let attr of this.model.get("attrs").models) {
            lines.push(this.writeAttr(attr, true));
        }
        lines = lines.concat(this.writeColours());
        this.writeFile(lines);
    }

    writeFile(lines) {
        let blob = new Blob(lines, {type: "text/plain;charset=iso-8859-1"});
        FileSaver.saveAs(blob, "muttrc");
    }

    writeAttr(attr, always) {
        let quote = _.contains(["boolean", "number", "quadoption"], attr.get("type")) ? "" : "'";
        let line = "set " + attr.get("id") + " = " + quote + attr.currentValue() + quote;
        if (attr.defaultValue() === attr.currentValue()) {
            if (always) {
                line = "# " + line;
            } else {
                return null;
            }
        } else {
            line += " # default: " + attr.get("default");
        }
        line += "\n";
        return line;
    }

    writeColours() {
        const padTo = (val, size) => {
            while (val.length < size) {
                val += " ";
            }
            return val;
        };

        let anyColoursSet = false;
        for (let ss of ScreenSections.models) {
            if (ss.isSet()) {
                anyColoursSet = true;
                break;
            }
        }

        if (!anyColoursSet) {
            return [];
        }

        return ["\n"].concat(
            ScreenSections.models.map(
                ss => "color " + padTo(ss.get("id"), 12) + " " + padTo(ss.fg().get("id"), 10) + " " + ss.bg().get("id") + "\n"
            )
        );
    }

    saveManualFormat() {
        let seen = {};
        let lines = this.getFileHeader();
        let currentCommand = null;

        for(let line of this.model.get("text").split("\n")) {
            if (/^#  [A-Za-z]/.test(line)) {
                if (currentCommand) {
                    seen[currentCommand] = true;
                    lines.push(this.writeAttr(this.model.get("attrs").get(currentCommand), true));
                    lines.push("#\n");
                    lines.push("##########\n");
                }
                currentCommand = line.substring(3);
            }
            if (line != "#  END") {
                lines.push(line + "\n");
            }
        }

        let first = true;
        for (let attr of this.model.get("attrs").models) {
            if (!seen[attr.get("id")]) {
                if (first) {
                    first = false;
                    lines.push("\n");
                    lines.push("# Other variables");
                    lines.push("\n");
                }
                lines.push(this.writeAttr(attr, true));
            }
        }

        lines = lines.concat(this.writeColours());
        this.writeFile(lines);
    }

    saveCategoryFormat() {
        let lines = this.getFileHeader();
        let byCategory = {};
        for (let attr of this.model.get("attrs").models) {
            let cat = attr.get("category") || "default";
            if(!byCategory[cat]) {
                byCategory[cat] = [];
            }
            byCategory[cat].push(attr);
        }

        for(let cat of Object.keys(byCategory).sort()) {
            lines.push("##########\n");
            lines.push("# Category " + cat + "\n");
            lines.push("##########\n");
            lines.push("\n");
            for(let attr of byCategory[cat]) {
                lines.push(this.writeAttr(attr, true));
            }
            lines.push("\n");
        }

        lines = lines.concat(this.writeColours());
        this.writeFile(lines);
    }
}

export default ChooseFormatView;
